================================================================================================================
-} GNU Assembly para Geral (Diretivas, Instruções e Registradores, Mapeamento de Memória, Entrada, Gráficos, Áudio e Online):
================================================================================================================
=============
-> Diretivas:
=============
1. Seções de Código e Dados:
.text: Define o início da seção de código (instruções executáveis).
.data: Define o início da seção de dados inicializados (variáveis com valor inicial).
.rodata: Define a seção de dados somente leitura (como strings e constantes).
.bss: Define a seção de dados não inicializados (variáveis que serão zeradas em tempo de execução).
.section: Uma alternativa mais genérica para definir uma seção.
.code16: Define a seção de código 16-bit.
.code32: Define a seção de código 32-bit.
.code64: Define a seção de código 64-bit.

2. Definição de Dados e Alocação de Espaço:
.byte: Insere um ou mais bytes de dados.
.short ou .hword: Insere um ou mais valores de 16 bits.
.long ou .word ou .int: Insere um ou mais valores de 32 bits.
.quad ou .8byte: Insere um ou mais valores de 64 bits.
.ascii: Insere uma string sem o terminador nulo.
.asciz: Insere uma string terminada em nulo (\0). (Mais comum para strings).
.equ: Define um símbolo com um valor constante.
.space ou .skip: Reserva uma quantidade de bytes, opcionalmente com um valor de preenchimento.
.align: Alinha o próximo dado ou instrução a um limite de endereço específico (ex: alinhamento de 4 ou 16 bytes).
.lcomm: Reserva espaço na seção .bss (dados não inicializados).

3. Prefixos, Símbolos e Sufixos:

3.1. Prefixos:
$: Prefixo usado para denotar que o operando é um valor literal (constante) e não um endereço de memória ou um registrador.
%: Prefixo usado antes do nome de um registrador para identificá-lo explicitamente. (Ex: %rax, %rsp, %rdi).
(): Indica que o valor entre parênteses é um endereço de memória cujo conteúdo deve ser acessado.
#: Usado para iniciar um comentário de linha única.
: - Define um rótulo, que é um nome simbólico para um endereço de memória (código ou dado), usado como alvo de instruções de salto (JMP, CALL) ou para referenciar dados.
*: Usado antes de um operando (registrador ou memória) para indicar que o alvo de um JMP ou CALL é o conteúdo desse operando (o endereço está no registrador/memória).
.: Endereço Atual/Diretiva

3.2. Sufixos de Tamanho de Byte para Instruções:
B: Byte (8 bits).
W: Word (16 bits).
L: Long (32 bits).
Q: Quadword (64 bits).
T: Ten bytes (80 bits).
----------------------------------------------------

4. Símbolos:
.globl ou .global: Torna o símbolo visível para outros arquivos objeto (exporta a função ou variável). Essencial para a função de entrada principal.
.local: Torna o símbolo visível apenas dentro do arquivo atual.
.type: Define o tipo de um símbolo (ex: @function ou @object).
.size: Define o tamanho do símbolo.
.set: Atribui o valor de uma expressão a um símbolo.
______________________________________________________________________________________________________________________________________________________________________
==============
-> Instruções:
==============
1. Aritmética (Uso: ADD/SUB %r1, %r2, IMUL/IDIV/DEC/NEG %r1, %r2):
ADD: Soma o primeiro operando ao segundo operando, armazenando no segundo.
SUB: Subtrai o primeiro operando do segundo operando, armazenando no segundo.
IMUL: Multiplica os operandos; o resultado pode ser armazenado em um operando ou implicitamente em %ax:%dx/%eax:%edx/%rax:%rdx/%r0:%r3/%x0:%x3/%r0:%r3.
IDIV: Divide o valor em %dx:%ax/%edx:%eax/%rdx:%rax/%r3:%r0/%x3:%x0/%r3:%r0 pelo operando; armazena o quociente em RAX e o resto em RDX.
INC: Incrementa o operando em 1.
DEC: Decrementa o operando em 1.
NEG: Nega o valor do operando (converte para o complemento de dois).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Manipulação de Dados/Memória (Uso: Instrução %r1, %r2):
MOV: Move o valor do primeiro operando (fonte) para o segundo operando (destino).
LEA: Calcula o endereço efetivo do primeiro operando e o move para o segundo operando (destino).
LOAD: Calcula um endereço do primeiro operando e move para o segundo operando.
STORE: Armazena um dado de um operando na memória.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
3. Instruções Lógicas e de Manipulação de Bits (Uso: Operação %r1, %r2, nas deslocações, Instrução $valor, %r1):
AND: Realiza a operação AND bit a bit entre os operandos.
OR: Realiza a operação OR bit a bit entre os operandos.
XOR: Realiza a operação XOR bit a bit entre os operandos.
NOT: Inverte todos os bits do operando.
SHL: Desloca os bits para a esquerda, preenchendo com zeros à direita. É equivalente a multiplicar por 2n.
SHR: Desloca os bits para a direita, preenchendo com zeros à esquerda. Usado para números sem sinal.
SAR: Desloca os bits para a direita, preenchendo com o bit de sinal à esquerda para preservar o sinal do número. Usado para números com sinal.
ROL: Rotaciona os bits para a esquerda. O bit que sai do mais significativo retorna para o menos significativo.
ROR: Rotaciona os bits para a direita. O bit que sai do menos significativo retorna para o mais significativo.
RCL: Rotaciona o operando junto com o Carry Flag (CF).
RCR: Rotaciona o operando junto com o Carry Flag (CF).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Salto Condicional (Uso: CMP %r1, $valor, JMP rótulo):
CMP: Compara os dois operandos, alterando os flags (Zero, Sinal, Overflow, etc.).
TEST: Realiza uma operação AND lógica bit a bit e apenas altera os flags.
JMP: Salto incondicional para o rótulo especificado.
JE: Salto se o resultado da última comparação/operação foi Igual (ZF=1).
JNE: Salto se o resultado da última comparação/operação foi Diferente (ZF=0).
JG: Salto se Maior (salto condicional considerando valores com sinal).
JL: Salto se Menor (salto condicional considerando valores com sinal).
JGE: Salto se Maior ou Igual (salto condicional considerando valores com sinal).
JLE: Salto se Menor ou Igual (salto condicional considerando valores com sinal).
--------------------------------------------------------------------------------------------------------------------------------
5. Pilha (Uso: PUSH/POP %reg_ou_mem, CALL rótulo):
PUSH: Empurra o valor do operando para a pilha, decrementando o ponteiro da pilha (%PILHA).
POP: Retira o valor do topo da pilha para o operando destino, incrementando o ponteiro da pilha (%PILHA).
CALL: Empurra o endereço da próxima instrução para a pilha e salta para a sub-rotina.
RET: Retira o endereço do topo da pilha e salta para esse endereço (retorno de sub-rotina).
IRET:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
6. I/O (Uso: INT $1, %ax/%eax/%rax/%r0/%x0/%r3):
INT: Executa uma interrupção.
IN: Envia um sinal de entrada.
OUT: Envia um sinal de saída.
________________________________________________________________________________________________________________________________________________________________________________
=============================================================
-} SystemV ABI (Para Interações com Código C Externo e Bibliotecas):
=============================================================
1. SystemV ABI x32:
Retorno: %ACUMULADOR.
Callee-Saved (Preservados na Chamada): %BASE, %FONTE, %DESTINO, %PILHA.
Caller-Saved (Preservados na Função): %ACUMULADOR, %CONTADOR, %DADOS.

2. SystemV ABI x64:
Retorno: %ACUMULADOR
Callee-Saved (Preservados na Chamada): %BASE, %BÔNUS, %PILHA, %R12-15.
Caller-Saved (Preservados na Função): %ACUMULADOR, %CONTADOR, %DADOS, %FONTE, %DESTINO, %R8-R11.
________________________________________________________________________________________________________________
====================================================
-> Registradores (x86, ARM e PowerPC):
====================================================
1. x86:
-] 8-bit:
-----------
AL: Acumulador Baixo/Low
AH: Acumulador Alto/High
BL: Base Baixa/Low
BH: Base Alta/High
CL: Contador Baixo/Low
CH: Contador Alto/High
DL: Dados Baixos/Low
DH: Dados Altos/High
-------------------------------------------
-] 16-bit:
-------------
1. Caller-Saved (Registrador):
AX: Accumulator Register (Registrador Acumulador)
BX: Base Register (Registrador Base)
CX: Counter Register (Registrador Contador)
DX: Data Register (Registrador de Dados)
----------------------------------------------------------------------------------
2. Callee-Saved (Chamada):
DI: Destination Index (Índice de Destino)
SI: Source Index (Índice de Fonte)
BP: Base Pointer (Ponteiro Base)
SP: Stack Pointer (Ponteiro de Pilha)
----------------------------------------------------------------
-] 32-bit:
-------------
1. Caller-Saved (Registrador):
EAX: Extended Accumulator Register
EBX: Extended Base Register
ECX: Extended Counter Register
EDX: Extended Data Register
------------------------------------------------------------
2. Callee-Saved (Chamada):
EDI: Extended Destination Index
ESI: Extended Source Index
EBP: Extended Base Pointer
ESP: Extended Stack Pointer
------------------------------------------------------------------
-] 64-bit:
-------------
1. Caller-Saved (Registrador):
RAX: Register Accumulator
RBX: Register Base
RCX: Register Counter
RDX: Register Data
------------------------------------------------------------
2. Callee-Saved (Chamada):
RDI: Register Destination Index
RSI: Register Source Index
RBP: Register Base Pointer
RSP: Register Stack Pointer
R8 - R9: Registers 8 and 9 (Registradores de Propósito Geral)
R10 - R15: Registradores Gerais
--------------------------------------------------------------------------------------------------
2. ARMv7/v8 (x32, x64):
-] 32-bit:
-------------
1. Caller-Saved (Registrador/Função):
R0: Argumento 1 / Valor de Retorno
R1: Argumento 2
R2: Argumento 3
R3: Argumento 4
------------------------------------------------------------
2. Callee-Saved (Chamada):
R4: Variável Local (Preservado pela Chamada)
R11: Frame Pointer (Ponteiro de Frame) / Variável Local
R13: Stack Pointer (SP)
R14: Link Register (LR) (Endereço de Retorno da Função)
------------------------------------------------------------------------------------------
-] 64-bit:
X0: Argumento de Função
X19: Variável Local
X1: Argumento de Função
X2: Argumento de Função
X3: Argumento de Função
X4: Argumento de Função
SP: Stack Pointer
X29: Frame Pointer
-------------------------------------------
3. PowerPC (x32, x64)
1. Caller-Saved (Registrador):
R3: Argumento 1 / Valor de Retorno
R4: Argumento 2
R5: Argumento 3
R6: Argumento 4
R7: Argumento 5
---------------------------------------------------------
2. Callee-Saved (Chamada):
R1: Stack Pointer (Ponteiro de Pilha)
R14: Volátil (Variável Temporária)
R30 - R31: Variáveis Locais (Preservados pela Chamada)
______________________________________________________________________________________________________________________________________________________________________
=======================================================================
-} Entrada (Para suporte de controles do Computador, Celular e Console)
=======================================================================
Uso: CALL [Função/Comando] e CMP [hex], 1. Em celulares, CMP [Comando], 1
-----------------------------------------------------------------------------------------------------------------------------
-> Parâmetros-Chave:
PRESSED_KEY: .byte 0x00: Deve ser movido para %ACUMULADOR
---------------------------------------------------------------------------------------------------------
-> Computador:
0x01 - Esc
0x02 - 1
0x03 - 2
0x04 - 3
0x05 - 4
0x06 - 5
0x07 - 6
0x08 - 7
0x09 - 8
0x0A - 9
0x0B - 0
0x0C - -
0x0D - =
0x0E - Backspace
0x0F - Tab
0x10 - Q
0x11 - W
0x12 - E
0x13 - R
0x14 - T
0x15 - Y
0x16 - U
0x17 - I
0x18 - O
0x19 - P
0x1A - ´ (acento agudo)
0x1B - [ (abre colchete)
0x1C - Enter
0x1D - Ctrl esquerdo
0x1E - A
0x1F - S
0x20 - D
0x21 - F
0x22 - G
0x23 - H
0x24 - J
0x25 - K
0x26 - L
0x27 - Ç
0x28 - ~ (til)
0x29 - ` (crase)
0x2A - Shift esquerdo
0x2B - \ (barra invertida)
0x2C - Z
0x2D - X
0x2E - C
0x2F - V
0x30 - B
0x31 - N
0x32 - M
0x33 - , (vírgula)
0x34 - . (ponto)
0x35 - ; (ponto e vírgula)
0x36 - Shift direito
0x37 - * (no teclado numérico)
0x38 - Alt esquerdo
0x39 - Espaço
0x3A - Caps Lock
0x3B - F1
0x3C - F2
0x3D - F3
0x3E - F4
0x3F - F5
0x40 - F6
0x41 - F7
0x42 - F8
0x43 - F9
0x44 - F10
0x45 - Num Lock
0x46 - Scroll Lock
0x47 - 7 (teclado numérico)
0x48 - 8
0x49 - 9
0x4A - -
0x4B - 4
0x4C - 5
0x4D - 6
0x4E - +
0x4F - 1
0x50 - 2
0x51 - 3
0x52 - 0
0x53 - . (ponto do teclado numérico)
0x57 - F11
0x58 - F12
----------------------------------------------------------
-> Celular :
I2C_START_TRANSMISSION: Gerar a condição START (SDA LOW, SCL HIGH). Iniciar a comunicação com o TCIC.
I2C_SEND_SLAVE_ADDR_WRITE <0x00>: Enviar o endereço do TCIC + bit de escrita (0). Dizer ao TCIC para escutar o endereço de registro.
I2C_SEND_SLAVE_ADDR_READ <0x00>: Gerar REPEATED START ou START + Endereço do TCIC + bit de leitura (1). Dizer ao TCIC para enviar os dados.
I2C_WRITE_BYTE (REG_ADDR): Enviar o endereço do registrador interno do TCIC (ex: 0x814E). Especificar qual dado (status, X, Y, pressão) o TCIC deve retornar.
I2C_READ_BYTE (ACK/NACK): Ler 8 bits do TCIC. Receber o Status, a Posição, ou o valor de Pressão.
I2C_STOP_TRANSMISSION: Gerar a condição STOP (SDA HIGH, SCL HIGH). Finalizar a transação.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-] Consoles:
1. PlayStation:
Cima: 0x00
Direita: 0x02
Baixo: 0x04
Esquerda: 0x06
Centro: 0x08 ou 0x0F
Quadrado: 0x60
X: 0x61
Bolinha: 0x62
Triângulo: 0x63
L1: 0x64
R1: 0x65
L2: 0x66
R2: 0x67
Share: 0x68
Options: 0x69
L3: 0x6C
R3: 0x6D
Touchpad: 0x6A
LEFT_STICK_X (0x0000 a 0xFFFF): .short 0x0000
LEFT_STICK_Y (0x0000 a 0xFFFF): .short 0x0000
RIGHT_STICK_X (0x0000 a 0xFFFF): .short 0x0000
RIGHT_STICK_Y (0x0000 a 0xFFFF): .short 0x0000
--------------------------------------------------------------------------------
2. Xbox:
D-Pad Cima: 0x01
D-Pad Baixo: 0x02
D-Pad Direita: 0x03
D-Pad Esquerda: 0x04
Start: 0x05
Back: 0x06
L-Stick: 0x07
R-Stick: 0x08
A: 0x0C
B: 0x0D
X: 0x0E
Y: 0x0F
LB: 0x09
RB: 0x0A
LT (0x00 a 0xFF): .byte 0x00
RT (0x00 a 0xFF): .byte 0x00
________________________________
==========================
-} Mapeamento de Memória:
==========================
> Usa uma interrupção para ver o mapa de memória, permitindo que você possa escrever na RAM.

1. x16:
INT 15h, %ACUMULADOR=E820h
---------------------------------
2. x32:
INT 0x00000015, ACUMULADOR=0x0000E820
-----------------------------------------------------------
3. x64:
INT 0x0000000000000015, %ACUMULADOR=0x000000000000E820
____________________________________________________________________________________________________________
==========
-} Disco:
==========
Leitura: Mover %ACUMULADOR para 0x38(%BASE) em um loop, realizar operação lógica AND com %ACUMULADOR e valor 0x88, comparar %ACUMULADOR com 0 e pular para o loop se %ACUMULADOR não for zero.
Escrita: Mover o valor 0x1 para %ACUMULADOR
______________________________________________________________________________________________________________________________________________________________________________________________________________________
============
-} Gráficos:
============
! Nota: Todos os dados devem estar em %BASE
> Requer a chamada de códigos do GUC/SMU/GSP/SOC-GSP, e o código inteiro em um .sys/.ko empacotado com um executor dele.

1. Comandos do GSP (CALL para uso):
- Padrão de Alocação é o tamanho da memória em bytes, HeapID é VRAM e 4096 é o alinhamento em PCs/Consoles.

-] Intel:
Iniciar: GUC_CMD_GLOBAL_INIT
Alocar: GUC_CMD_ALLOC_RESOURCE <SIZE>, <HeapID>, <ALIGN>
Escrever: GUC_CMD_QUEUE_RING_FLUSH
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-] AMD:
Iniciar: SMU_CMD_INIT_PM
Alocar/Escrever: SMU_CMD_ALLOCATE_MEM <SIZE>, <HeapID>, <ALIGN>
---------------------------------------------------------------------------------------------------------------------
-] NVidia:
Iniciar: GSP_CMD_INIT_RM $0x1
Alocar: GSP_CMD_ALLOC_OBJECT <SIZE>, <HeapID>, <ALIGN>
Escrever: GSP_CMD_SUBMIT_WORK
----------------------------------------------------------------------------------------------------
-] SOC-GSP:
Iniciar: GSP_RESET $0x1, GSP_CLK_CFG $0x0
Ler (Requer comparação com zero e loop caso não seja zero): JOB_STATUS
Escrever: JOB_RING_BASE $0x0, JOB_RING_WTPR $0x0

2. Células, Valores RGB Indexados e Coordenadas de Posição:
> Um valor de cor varia de 0 a 255 (0x00 a 0xFF), e um offset da célula deve ser defindo antes da escrita na memória de vídeo.
> Fórmula do OFFSET: Offset da Célula} = (Y_Célula * 128 + X_Célula)

.section .data
R .byte 0x00: Nível da Cor Vermelha
G .byte 0x00: Nível da Cor Verde
B .byte 0x00: Nível da Cor Azul
CELL1 .ascii [desenho]
CELL1_OFFSET (20 * 128 * 10)
____________________________________________________________________________________________________________________________________________________________________________________________________________________
========================================================
-} Áudio (Para efeitos sonoros e músicas no seu código):
========================================================
! Nota: Todos os dados devem estar em %BASE.
> Requer "INT 15h/0x15/0x00000015/0x0000000000000015, %ACUMULADOR=E820h/0x0000E820/0x000000000000E820", Delta Pi no Base e chamada de códigos do HDA, além do código de todo o projeto em um arquivo .sys/.ko e seu executor.

1. Chamadas de Comandos do HDA (Universal em PCs):
- Padrôes de formato de stream são NID 0x06, Stream Format 0x200, e Payload 0x441.
- Padrões de Ativação do Dispositivo de Áudio são 0x40 para a Saída e 0x80 para o Headphone.
CALL SET_STREAM_FORMAT <NID> <STREAM_FORMAT> <PAYLOAD>: Define a taxa, bits e canais para 48kHz/16bit/Estéreo no DAC/ADC.
CALL SET_PIN_WIDGET_CONTROL <NID> <ENABLE_OUT>: Ativa o pino de saída físico (Ex: Headphone) e sua função de saída.
MOV [DELTA_PI], %BX/%EBX/RBX/%R1/%X1/%R4
CALL SET_DMA_RUN_BIT: Aciona o controlador HDA para iniciar o loop de transferência de dados do Ring Buffer para o CODEC.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Definição de Parâmetros de Áudio, Low/Neg_Max e High/Max:
PI .double 3.14159265358979323846: Número PI.
SAMPLE_RATE .equ 44100: Frequência de amostragem (Fs).
FREQUENCY .short 440: Frequência do seno (f).
DURATION .byte 1: Duração em segundos.
BITS_PER_SAMPLE .byte 16: Profundidade de bits.
MAX_AMPLITUDE .short 32767: Amplitude de Bits.
NEG_MAX_AMPLITUDE .short -32767: Amplitude Negativa de Bits.
----------------------------------------------------------------------------------------------------------
3. Cálculo da Onda Senoidal:

.section .bss
PHASE_ACC: resd 1: DoubleWord reservado para o Acumulador de Fase.
DELTA_PI: .long 42852281: Incremento de Fase (Frequência * 2^32 / Sample Rate).
__________________________________________________________________________________
==========================
-} Online (Intel FW e TCP/IP):
==========================
1. Comandos do Firmware de Rede Intel:
CTRL $0x0000: Controle Geral do Chip (Reset, Enable/Disable)
STATUS $0x0008: Status Geral do Link (Link Up/Down)
EERD $0x0014: Leitura da EEPROM/NVM (para ler o MAC)
IMC $0x00D0: Máscara de Interrupção (para ignorar/habilitar interrupções)
RCTL $0x0100: Controle de Recepção
RAL/RAH $0x5400/0x5404: Endereço MAC (Lower/Upper 32 bits)
RDBAL/RDBAH $0x2800/0x2804: Endereço Base do Anel de Descritores Rx (Lower/Upper)
RDLEN $0x2808: Tamanho do Anel de Descritores Rx
RDH/RDT 0x2810/0x2818: Cabeça (Head) e Cauda (Tail) do Anel Rx
TCTL $0x0400: Controle de Transmissão
TDBAL/TDBAH $0x3800/0x3804: Endereço Base do Anel de Descritores Tx
TDLEN $0x3808: Tamanho do Anel de Descritores Tx
TDH/TDT $0x3810/0x3818: Cabeça (Head) e Cauda (Tail) do Anel Tx
----------------------------------------------------------------------------------------------------------------------------------------------
2. Parâmetros do TCP/IP:

2.1. Frame Ethernet 
MAC_DESTINY 0x00: Endereço MAC do próximo dispositivo na rede (roteador ou host final). (Variável)
MAC_ORIGIN 0x06: Seu endereço MAC. (Variável). (Este é o MAC lido do NIC da Intel).
ETHERTYPE $0x0C: Identifica o protocolo da Camada 3. (Padrão/Fixo):0x0800 para IPv4, 0x0806 para ARP.
PAYLOAD $0x0E: O Cabeçalho IP começa aqui.
CRC (Checksum de Frame): Este campo é gerado e anexado AUTOMATICAMENTE pelo controlador Intel no momento da transmissão.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.2. Cabeçalho IPv4:
VERSION_IHL $0x00>: Geralmente 0x45. (Versão 4, IHL 5 - 20 bytes).
PROTOCOL <$0x09>: 0x06 (para TCP) ou 0x11 (para UDP).
CHKSUM_HEADER 0x0A: O campo que você deve calcular em bare-metal, usando o algoritmo de Soma Complementar de Um.
IP_ORIGIN 0x0C: Seu Endereço IP. (Variável).
IP_DESTINY 0x10: Endereço IP do host de destino. (Variável).
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.3. Cabecalho TCP:
PORT_ORIGIN $0x00>: Sua porta (aplicação/serviço local).
PORT_DESTINY $0x02: Porta do serviço remoto (ex: 80, 443).
SEQUENCE $0x04: Posição do primeiro byte de dados do segmento.
ACK (Reconhecimento) <0x08>: Próximo número de sequência esperado do lado remoto.
RES_FLAGS $0x0C$: Contém o Data Offset e os Control Flags.
WINDOW_SIZE $0x0E: Controle de fluxo (Buffer de recepção disponível).
CHKSUM $0x10: Resultado do cálculo do Pseudo-Cabeçalho + TCP + Dados.
URGENCY_POINT $0x12: Ponto de Urgência Fixo (Geralmente 0x0000).
OPT_FILL $0x14: Usado se o Data Offset for maior que 5.
SYN (Início): $0x02
SYN-ACK (Resposta): $0x12 (0x10 ACK + 0x02 SYN)
SIM-ACK (Reconhecimento): $0x10
PSH-ACK (Enviar Dados): $0x18 (0x08 PSH + 0x10 ACK)
FIN-ACK (Encerrar): $0x11 (0x01 FIN + 0x10 ACK)
RST (Resetar): $0x04

3. APIC:
Configuração da APIC: Sequências de OUTs e MOVs para os endereços do Firmware de Rede Intel.
Rotina de Serviço: Salvar Contexto, Ler e Escrever nos pacotes do NIC, e restaurar.
Loops: Loop de Jumps entre as tarefas.
__________________________________________________________________________________________________