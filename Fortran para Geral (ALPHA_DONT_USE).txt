========================================================================================================================
-} Fortran 77 para Geral (Regras, Operadores, Palavras-Chave, Mapeamento de Memória, Entrada, Gráficos, Áudio e Online):
========================================================================================================================
Regras do Formato Fixo do Fortran 77:
Coluna 1, Regra: Se a coluna 1 contiver um C, um * (asterisco), ou um D (dependendo do compilador), a linha inteira é tratada como um comentário e ignorada."
Colunas 1 a 5, Regra: Espaço reservado para números inteiros (rótulos) de 1 a 5 dígitos. Esses rótulos são usados por instruções como GO TO, DO, READ e WRITE (para referenciar instruções FORMAT). O número não precisa estar justificado à direita.
Coluna 6, Regra: Se uma instrução for muito longa para caber na coluna 72, a próxima linha é uma continuação se a coluna 6 contiver qualquer caractere que não seja um espaço ou 0 (zero). O + ou um número sequencial eram populares.
Colunas 7 a 72, Regra: Aqui é onde o código real reside (declarações, instruções executáveis). Importante: Os espaços em branco são geralmente ignorados pelo Fortran 77 (com exceção de strings de caracteres). Por exemplo, I N T E G E R é lido como INTEGER.
Colunas 73 a 80, Regra: Essas colunas são ignoradas pelo compilador. Elas eram usadas para armazenar números de sequência em cartões perfurados para ajudar na classificação, caso os cartões fossem misturados.

==============
-> Operadores:
==============
.AND., .OR., .NOT., .EQ., .NE., .LT., .LE., .GT., .GE.: Operadores Lógicos Bit-a-Bit e de Salto

==================
-> Palavras-Chave:
==================
PROGRAM: Inicia o programa principal.
ENDPROGRAM: Finaliza o programa principal.
INTEGER: Declara uma variável como número inteiro.
REAL: Declara uma variável como número de ponto flutuante (precisão simples).
DOUBLE PRECISION: Tipos,Declara uma variável de ponto flutuante de precisão dupla.
COMPLEX: Declara uma variável como número complexo.
LOGICAL: Declara uma variável booleana (.TRUE. ou .FALSE.).
CHARACTER: Declara uma variável de string (e.g., CHARACTER(LEN=20)).
DIMENSION: Declara o rank e os limites de um array.
PARAMETER: Declara uma constante simbólica.
FUNCTION: Inicia a definição de uma função (retorna um valor).
SUBROUTINE: Inicia a definição de uma sub-rotina (não retorna valor por nome).
CALL: Invoca/executa uma sub-rotina.
CONTAINS: Separa o código principal de procedimentos internos (FUNCTION ou SUBROUTINE).
RETURN: Sai de uma função ou sub-rotina.
IF: Inicia uma estrutura condicional.
THEN: Usado após a condição IF.
ELSE: Bloco de código executado se a condição IF for falsa.
ELSE IF Bloco de código para uma condição alternativa.
ENDIF: Finaliza a estrutura condicional IF.
DO: Inicia um loop (iteração).
ENDDO: Finaliza o loop DO.
CYCLE: Pula para a próxima iteração do loop DO.
EXIT: Sai imediatamente de um loop DO.
READ: Comando de entrada de dados (e.g., do teclado ou arquivo).
WRITE: Comando de saída de dados (e.g., para tela ou arquivo).
OPEN: Abre um arquivo para I/O.
CLOSE: Fecha um arquivo aberto.
UNIT: Argumento que especifica um número para o canal de I/O.
FORMAT: Especifica o layout da entrada ou saída formatada.
STOP: Encerra a execução do programa de forma normal.

====================================================================
-} SystemV ABI (Para Interações com Código C Externo e Bibliotecas):
====================================================================
1. SystemV ABI x32:
Retorno: AX/EAX/RAX/RBX.
Callee-Saved (Preservados na Chamada): %BASE, %FONTE, %DESTINO, %PILHA.
Caller-Saved (Preservados na Função): %ACUMULADOR, %CONTADOR, %DADOS.

2. SystemV ABI x64:
Retorno: %ACUMULADOR
Callee-Saved (Preservados na Chamada): %BASE, %BÔNUS, %PILHA, %R12-15.
Caller-Saved (Preservados na Função): %ACUMULADOR, %CONTADOR, %DADOS, %FONTE, %DESTINO, %R8-R11.

========================================================================
-} Entrada (Para suporte de controles do Computador, Celular e Console):
========================================================================
Uso: CALL [Função/Comando] e IF PRESSED_KEY == 1
-------------------------------------------------------------------------
-> Parâmetros-Chave:
PRESSED_KEY = Z'00': Deve ser movido para %ACUMULADOR
---------------------------------------------------------
-> Computador:
0x01 - Esc
0x02 - 1
0x03 - 2
0x04 - 3
0x05 - 4
0x06 - 5
0x07 - 6
0x08 - 7
0x09 - 8
0x0A - 9
0x0B - 0
0x0C - -
0x0D - =
0x0E - Backspace
0x0F - Tab
0x10 - Q
0x11 - W
0x12 - E
0x13 - R
0x14 - T
0x15 - Y
0x16 - U
0x17 - I
0x18 - O
0x19 - P
0x1A - ´ (acento agudo)
0x1B - [ (abre colchete)
0x1C - Enter
0x1D - Ctrl esquerdo
0x1E - A
0x1F - S
0x20 - D
0x21 - F
0x22 - G
0x23 - H
0x24 - J
0x25 - K
0x26 - L
0x27 - Ç
0x28 - ~ (til)
0x29 - ` (crase)
0x2A - Shift esquerdo
0x2B - \ (barra invertida)
0x2C - Z
0x2D - X
0x2E - C
0x2F - V
0x30 - B
0x31 - N
0x32 - M
0x33 - , (vírgula)
0x34 - . (ponto)
0x35 - ; (ponto e vírgula)
0x36 - Shift direito
0x37 - * (no teclado numérico)
0x38 - Alt esquerdo
0x39 - Espaço
0x3A - Caps Lock
0x3B - F1
0x3C - F2
0x3D - F3
0x3E - F4
0x3F - F5
0x40 - F6
0x41 - F7
0x42 - F8
0x43 - F9
0x44 - F10
0x45 - Num Lock
0x46 - Scroll Lock
0x47 - 7 (teclado numérico)
0x48 - 8
0x49 - 9
0x4A - -
0x4B - 4
0x4C - 5
0x4D - 6
0x4E - +
0x4F - 1
0x50 - 2
0x51 - 3
0x52 - 0
0x53 - . (ponto do teclado numérico)
0x57 - F11
0x58 - F12
------------------------------------
-> Celular :
I2C_START_TRANSMISSION: Gerar a condição START (SDA LOW, SCL HIGH). Iniciar a comunicação com o TCIC.
I2C_SEND_SLAVE_ADDR_WRITE <0x00>: Enviar o endereço do TCIC + bit de escrita (0). Dizer ao TCIC para escutar o endereço de registro.
I2C_SEND_SLAVE_ADDR_READ <0x00>: Gerar REPEATED START ou START + Endereço do TCIC + bit de leitura (1). Dizer ao TCIC para enviar os dados.
I2C_WRITE_BYTE (REG_ADDR): Enviar o endereço do registrador interno do TCIC (ex: 0x814E). Especificar qual dado (status, X, Y, pressão) o TCIC deve retornar.
I2C_READ_BYTE (ACK/NACK): Ler 8 bits do TCIC. Receber o Status, a Posição, ou o valor de Pressão.
I2C_STOP_TRANSMISSION: Gerar a condição STOP (SDA HIGH, SCL HIGH). Finalizar a transação.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-] Consoles:
1. PlayStation:
Cima: Z'00'
Direita: Z'02'
Baixo: Z'04'
Esquerda: Z'06'
Centro: Z'08' ou Z'0F'
Quadrado: Z'60'
X: Z'61'
Bolinha: Z'62'
Triângulo: Z'63'
L1: Z'64'
R1: Z'65'
L2: Z'66'
R2: Z'67'
Share: Z'68'
Options: Z'69'
L3: Z'6C'
R3: Z'6D'
Touchpad: Z'6A'
LEFT_STICK_X (Z'0000' a Z'FFFF'):
LEFT_STICK_Y (Z'0000' a Z'FFFF'):
RIGHT_STICK_X (Z'0000' a Z'FFFF'):
RIGHT_STICK_Y (Z'0000' a Z'FFFF'):
----------------------------------------------
2. Xbox:
D-Pad Cima: 0x01
D-Pad Baixo: 0x02
D-Pad Direita: 0x03
D-Pad Esquerda: 0x04
Start: 0x05
Back: 0x06
L-Stick: 0x07
R-Stick: 0x08
A: 0x0C
B: 0x0D
X: 0x0E
Y: 0x0F
LB: 0x09
RB: 0x0A
LT (0x00 a 0xFF): .byte 0x00
RT (0x00 a 0xFF): .byte 0x00

==========================
-} Mapeamento de Memória:
==========================
> Usa uma interrupção para ver o mapa de memória, permitindo que você possa escrever na RAM.

1. x16:
CALL INT Z'15h', %ACUMULADOR=E820h
--------------------------
2. x32:
CALL INT Z'00000015', %ACUMULADOR=Z'0000E820'
-------------------------------------
3. x64:
CALL INT Z'0000000000000015', %ACUMULADOR=Z'000000000000E820'

=========
-} Disco:
=========
Leitura: Mover %ACUMULADOR para 0x38(%BASE) em um loop, realizar operação lógica AND com %ACUMULADOR e valor 0x88, comparar %ACUMULADOR com 0 e pular para o loop se %ACUMULADOR não for zero.
Escrita: Mover o valor 0x1 para %ACUMULADOR

============
-} Gráficos:
============
! Nota: Todos os dados devem estar em *MAIN_ADDR
> Requer a chamada de códigos do GUC/SMU/GSP/SOC-GSP, e o código inteiro em um .sys/.ko empacotado com um executor dele.

1. Comandos do GSP (CALL para uso):
- Padrão de Alocação é o tamanho da memória em bytes, HeapID é "VRAM" e 4096 é o alinhamento em PCs/Consoles.

-> Parâmetros:
INTEGER SIZE, ALIGN
PARAMETER (SIZE = 1000000, ALIGN = 4096)
CHARACTER HEAPID
PARAMETER (HEAPID = "VRAM")

-] Intel:
Iniciar: GUC_CMD_GLOBAL_INIT (Antes do Alloc)
Alocar: GUC_CMD_ALLOC_RESOURCE <SIZE>, <HeapID>, <ALIGN>
Escrever: GUC_CMD_QUEUE_RING_FLUSH (Após a escrita na memória de vídeo.)
--------------------------------------------------------
-] AMD:
Iniciar: SMU_CMD_INIT_PM
Alocar/Escrever: SMU_CMD_ALLOCATE_MEM <SIZE>, <HeapID>, <ALIGN>
---------------------------------------------------------------
-] NVidia:
Iniciar: GSP_CMD_INIT_RM $0x1
Alocar: GSP_CMD_ALLOC_OBJECT <SIZE>, <HeapID>, <ALIGN>
Escrever: GSP_CMD_SUBMIT_WORK
------------------------------------------------------
-] SOC-GSP:
Iniciar: GSP_RESET Z'1', GSP_CLK_CFG Z'0'
Ler (Requer comparação com zero e loop caso não seja zero): JOB_STATUS
Escrever: JOB_RING_BASE $0x0, JOB_RING_WTPR Z'0'
----------------------------------------------------------------------------------------------------------
2. Elementos Gráficos:
█ Bloco Sólido: Z'DB'
▓ Sombra Escura: Z'B2'
▒ Sombra Média: Z'B1'
░ Sombra Leve: Z'B0'
----------------------
3. Células, Valores RGB Indexados e Coordenadas de Posição:
> Um valor de cor varia de 0 a 255 (Z'00' a Z'FF'), o OFFSET deve estar em *BASE_ADDR, e os dados gráficos da célula em *MAIN_ADDR.
> Fórmula do OFFSET: Offset da Célula = (Y_Célula * 160 + X_Célula * 3)

.section .data
R = Z'00' a Z'FF': Nível da Cor Vermelha
G = Z'00' a Z'FF': Nível da Cor Verde
B = Z'00' a Z'FF': Nível da Cor Azul
INTEGER RESOLUTION = 160
CHARACTER CELL1 = "desenho"
INTEGER CELL1_OFFSET, CELL1_Y, CELL1_X
PARAMETER WIDTH = 160, DEPTH = 3
CELL1_OFFSET = (CELL1_Y * 160 + CELL1_X * 3)

========================================================
-} Áudio (Para efeitos sonoros e músicas no seu código):
========================================================
! Nota: DELTA.PI deve estar em %CONTADOR e Dados de Áudio em %DADOS.
> Requer "INT 15h/0x15/0x00000015/0x0000000000000015, %ACUMULADOR=E820h/0x0000E820/0x000000000000E820", Delta Pi no Base e chamada de códigos do HDA, além do código de todo o projeto em um arquivo .sys/.ko e seu executor.

1. Chamadas de Comandos do HDA (Universal em PCs):
- Padrôes de formato de stream são NID Z'06', Stream Format Z'200', e Payload Z'441'.
- Padrões de Ativação do Dispositivo de Áudio são 0x40 para a Saída e 0x80 para o Headphone.
CALL SET_STREAM_FORMAT <NID> <STREAM_FORMAT> <PAYLOAD>: Define a taxa, bits e canais para 48kHz/16bit/Estéreo no DAC/ADC.
CALL SET_PIN_WIDGET_CONTROL <NID> <ENABLE_OUT>: Ativa o pino de saída físico (Ex: Headphone) e sua função de saída.
MOV [DELTA_PI], %BASE
CALL SET_DMA_RUN_BIT: Aciona o controlador HDA para iniciar o loop de transferência de dados do Ring Buffer para o CODEC.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Definição de Parâmetros de Áudio, Low/Neg_Max e High/Max:
PI .double 3.14159265358979323846: Número PI.
SAMPLE_RATE = 44100: Frequência de amostragem (Fs).
FREQUENCY = 440: Frequência do seno (f).
DURATION = 1: Duração em segundos.
BITS_PER_SAMPLE = 16: Profundidade de bits.
MAX_AMPLITUDE = 32767: Amplitude de Bits.
NEG_MAX_AMPLITUDE = -32767: Amplitude Negativa de Bits.
------------------------------------------------------------
3. Cálculo da Onda Senoidal:

DOUBLE PRECISION PHASE_ACC = 1
DELTA_PI: .long 42852281: Incremento de Fase (Frequência * 2^32 / Sample Rate).

==============================
-} Online (Intel FW e TCP/IP):
=============================
1. Comandos do Firmware de Rede Intel:
CTRL Z'0000': Controle Geral do Chip (Reset, Enable/Disable)
STATUS Z'0008': Status Geral do Link (Link Up/Down)
EERD Z'0014': Leitura da EEPROM/NVM (para ler o MAC)
IMC Z'00D0': Máscara de Interrupção (para ignorar/habilitar interrupções)
RCTL Z'0100': Controle de Recepção
RAL/RAH Z'5400'/Z'5404': Endereço MAC (Lower/Upper 32 bits)
RDBAL/RDBAH Z'2800'/Z'2804': Endereço Base do Anel de Descritores Rx (Lower/Upper)
RDLEN Z'2808': Tamanho do Anel de Descritores Rx
RDH/RDT Z'2810'/Z'2818': Cabeça (Head) e Cauda (Tail) do Anel Rx
TCTL Z'0400': Controle de Transmissão
TDBAL/TDBAH Z'3800'/Z'3804': Endereço Base do Anel de Descritores Tx
TDLEN Z'3808': Tamanho do Anel de Descritores Tx
TDH/TDT Z'3810'/Z'3818': Cabeça (Head) e Cauda (Tail) do Anel Tx
---------------------------------------------------------------------------------
2. Parâmetros do TCP/IP:

2.1. Frame Ethernet 
MAC_DESTINY Z'00': Endereço MAC do próximo dispositivo na rede (roteador ou host final). (Variável)
MAC_ORIGIN Z'06': Seu endereço MAC. (Variável). (Este é o MAC lido do NIC da Intel).
ETHERTYPE Z'0C': Identifica o protocolo da Camada 3. (Padrão/Fixo):Z'0800' para IPv4, Z'0806' para ARP.
PAYLOAD Z'0E': O Cabeçalho IP começa aqui.
CRC (Checksum de Frame): Este campo é gerado e anexado AUTOMATICAMENTE pelo controlador Intel no momento da transmissão.
------------------------------------------------------------------------------------------------------------------------
2.2. Cabeçalho IPv4:
VERSION_IHL Z'00': Geralmente 0x45. (Versão 4, IHL 5 - 20 bytes).
PROTOCOL Z'09': Z'06' (para TCP) ou Z'11' (para UDP).
CHKSUM_HEADER Z'0A': O campo que você deve calcular em bare-metal, usando o algoritmo de Soma Complementar de Um.
IP_ORIGIN Z'0C': Seu Endereço IP. (Variável).
IP_DESTINY Z'10': Endereço IP do host de destino. (Variável).
----------------------------------------------------------------------------------------------------------------
2.3. Cabecalho TCP:
PORT_ORIGIN Z'00': Sua porta (aplicação/serviço local).
PORT_DESTINY Z'02': Porta do serviço remoto (ex: 80, 443).
SEQUENCE Z'04': Posição do primeiro byte de dados do segmento.
ACK (Reconhecimento) Z'08': Próximo número de sequência esperado do lado remoto.
RES_FLAGS Z'0C': Contém o Data Offset e os Control Flags.
WINDOW_SIZE Z'0E': Controle de fluxo (Buffer de recepção disponível).
CHKSUM Z'10': Resultado do cálculo do Pseudo-Cabeçalho + TCP + Dados.
URGENCY_POINT Z'12': Ponto de Urgência Fixo (Geralmente 0x0000).
OPT_FILL Z'14': Usado se o Data Offset for maior que 5.
SYN (Início): Z'02'
SYN-ACK (Resposta): Z'12' (Z'10' ACK + Z'02' SYN)
SIM-ACK (Reconhecimento): Z'10'
PSH-ACK (Enviar Dados): Z'18' (Z'08' PSH + Z'10' ACK)
FIN-ACK (Encerrar): Z'11' (Z'01' FIN + Z'10' ACK)
RST (Resetar): Z'04'

3. APIC:
Configuração da APIC: Sequências de OUTs e MOVs para os endereços do Firmware de Rede Intel.
Rotina de Serviço: Salvar Contexto, Ler e Escrever nos pacotes do NIC, e restaurar.
Loops: Loop de Jumps entre as tarefas.
____________________________________________________________________________________________
