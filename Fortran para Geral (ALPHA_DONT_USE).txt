========================================================================================================================
-} Fortran 77 para Geral (Regras, Operadores, Palavras-Chave, Mapeamento de Memória, Entrada, Gráficos, Áudio e Online):
========================================================================================================================
Regras do Formato Fixo do Fortran 77:
Coluna 1, Regra: Se a coluna 1 contiver um C, um * (asterisco), ou um D (dependendo do compilador), a linha inteira é tratada como um comentário e ignorada."
Colunas 1 a 5, Regra: Espaço reservado para números inteiros (rótulos) de 1 a 5 dígitos. Esses rótulos são usados por instruções como GO TO, DO, READ e WRITE (para referenciar instruções FORMAT). O número não precisa estar justificado à direita.
Coluna 6, Regra: Se uma instrução for muito longa para caber na coluna 72, a próxima linha é uma continuação se a coluna 6 contiver qualquer caractere que não seja um espaço ou 0 (zero). O + ou um número sequencial eram populares.
Colunas 7 a 72, Regra: Aqui é onde o código real reside (declarações, instruções executáveis). Importante: Os espaços em branco são geralmente ignorados pelo Fortran 77 (com exceção de strings de caracteres). Por exemplo, I N T E G E R é lido como INTEGER.
Colunas 73 a 80, Regra: Essas colunas são ignoradas pelo compilador. Elas eram usadas para armazenar números de sequência em cartões perfurados para ajudar na classificação, caso os cartões fossem misturados.

==============
-> Operadores:
==============
.AND., .OR., .NOT., .EQ., .NE., .LT., .LE., .GT., .GE.: Operadores Lógicos Bit-a-Bit e de Salto

==================
-> Palavras-Chave:
==================
PROGRAM: Inicia o programa principal.
ENDPROGRAM: Finaliza o programa principal.
INTEGER: Declara uma variável como número inteiro.
REAL: Declara uma variável como número de ponto flutuante (precisão simples).
DOUBLE PRECISION: Tipos,Declara uma variável de ponto flutuante de precisão dupla.
COMPLEX: Declara uma variável como número complexo.
LOGICAL: Declara uma variável booleana (.TRUE. ou .FALSE.).
CHARACTER: Declara uma variável de string (e.g., CHARACTER(LEN=20)).
DIMENSION: Declara o rank e os limites de um array.
PARAMETER: Declara uma constante simbólica.
FUNCTION: Inicia a definição de uma função (retorna um valor).
SUBROUTINE: Inicia a definição de uma sub-rotina (não retorna valor por nome).
CALL: Invoca/executa uma sub-rotina.
CONTAINS: Separa o código principal de procedimentos internos (FUNCTION ou SUBROUTINE).
RETURN: Sai de uma função ou sub-rotina.
IF: Inicia uma estrutura condicional.
THEN: Usado após a condição IF.
ELSE: Bloco de código executado se a condição IF for falsa.
ELSE IF Bloco de código para uma condição alternativa.
ENDIF: Finaliza a estrutura condicional IF.
DO: Inicia um loop (iteração).
ENDDO: Finaliza o loop DO.
CYCLE: Pula para a próxima iteração do loop DO.
EXIT: Sai imediatamente de um loop DO.
READ: Comando de entrada de dados (e.g., do teclado ou arquivo).
WRITE: Comando de saída de dados (e.g., para tela ou arquivo).
OPEN: Abre um arquivo para I/O.
CLOSE: Fecha um arquivo aberto.
UNIT: Argumento que especifica um número para o canal de I/O.
FORMAT: Especifica o layout da entrada ou saída formatada.
STOP: Encerra a execução do programa de forma normal.



========================================================================================================================
-} Fortran 77 para Geral (Regras, Operadores, Palavras-Chave, Mapeamento de Memória, Entrada, Gráficos, Áudio e Online):
========================================================================================================================
Regras do Formato Fixo do Fortran 77:
Coluna 1, Regra: Se a coluna 1 contiver um C, um * (asterisco), ou um D (dependendo do compilador), a linha inteira é tratada como um comentário e ignorada."
Colunas 1 a 5, Regra: Espaço reservado para números inteiros (rótulos) de 1 a 5 dígitos. Esses rótulos são usados por instruções como GO TO, DO, READ e WRITE (para referenciar instruções FORMAT). O número não precisa estar justificado à direita.
Coluna 6, Regra: Se uma instrução for muito longa para caber na coluna 72, a próxima linha é uma continuação se a coluna 6 contiver qualquer caractere que não seja um espaço ou 0 (zero). O + ou um número sequencial eram populares.
Colunas 7 a 72, Regra: Aqui é onde o código real reside (declarações, instruções executáveis). Importante: Os espaços em branco são geralmente ignorados pelo Fortran 77 (com exceção de strings de caracteres). Por exemplo, I N T E G E R é lido como INTEGER.
Colunas 73 a 80, Regra: Essas colunas são ignoradas pelo compilador. Elas eram usadas para armazenar números de sequência em cartões perfurados para ajudar na classificação, caso os cartões fossem misturados.

==============
-> Operadores:
==============
.AND., .OR., .NOT., .EQ., .NE., .LT., .LE., .GT., .GE.: Operadores Lógicos Bit-a-Bit e de Salto

==================
-> Palavras-Chave:
==================
PROGRAM: Inicia o programa principal.
ENDPROGRAM: Finaliza o programa principal.
INTEGER: Declara uma variável como número inteiro.
REAL: Declara uma variável como número de ponto flutuante (precisão simples).
DOUBLE PRECISION: Tipos,Declara uma variável de ponto flutuante de precisão dupla.
COMPLEX: Declara uma variável como número complexo.
LOGICAL: Declara uma variável booleana (.TRUE. ou .FALSE.).
CHARACTER: Declara uma variável de string (e.g., CHARACTER(LEN=20)).
DIMENSION: Declara o rank e os limites de um array.
PARAMETER: Declara uma constante simbólica.
FUNCTION: Inicia a definição de uma função (retorna um valor).
SUBROUTINE: Inicia a definição de uma sub-rotina (não retorna valor por nome).
CALL: Invoca/executa uma sub-rotina.
CONTAINS: Separa o código principal de procedimentos internos (FUNCTION ou SUBROUTINE).
RETURN: Sai de uma função ou sub-rotina.
IF: Inicia uma estrutura condicional.
THEN: Usado após a condição IF.
ELSE: Bloco de código executado se a condição IF for falsa.
ELSE IF Bloco de código para uma condição alternativa.
ENDIF: Finaliza a estrutura condicional IF.
DO: Inicia um loop (iteração).
ENDDO: Finaliza o loop DO.
CYCLE: Pula para a próxima iteração do loop DO.
EXIT: Sai imediatamente de um loop DO.
READ: Comando de entrada de dados (e.g., do teclado ou arquivo).
WRITE: Comando de saída de dados (e.g., para tela ou arquivo).
OPEN: Abre um arquivo para I/O.
CLOSE: Fecha um arquivo aberto.
UNIT: Argumento que especifica um número para o canal de I/O.
FORMAT: Especifica o layout da entrada ou saída formatada.
STOP: Encerra a execução do programa de forma normal.

========================================================================
-} Entrada (Para suporte de controles do Computador, Celular e Console):
========================================================================
Uso: CALL [Função/Comando] e IF PRESSED_KEY == 1
-------------------------------------------------------------------------
-> Parâmetros-Chave:
PRESSED_KEY = Z'00': Deve ser movido para %ACUMULADOR
---------------------------------------------------------
-> Computador:
Z'01' - Esc
Z'02' - 1
Z'03' - 2
Z'04' - 3
Z'05' - 4
Z'06' - 5
Z'07' - 6
Z'08' - 7
Z'09' - 8
Z'0A' - 9
Z'0B' - 0
Z'0C' - -
Z'0D' - =
Z'0E' - Backspace
Z'0F' - Tab
Z'10' - Q
Z'11' - W
Z'12' - E
Z'13' - R
Z'14' - T
Z'15' - Y
Z'16' - U
Z'17' - I
Z'18' - O
Z'19' - P
Z'1A' - ´ (acento agudo)
Z'1B' - [ (abre colchete)
Z'1C' - Enter
Z'1D' - Ctrl esquerdo
Z'1E' - A
Z'1F' - S
Z'20' - D
Z'21' - F
Z'22' - G
Z'23' - H
Z'24' - J
Z'25' - K
Z'26' - L
Z'27' - Ç
Z'28' - ~ (til)
Z'29' - ` (crase)
Z'2A' - Shift esquerdo
Z'2B' - \ (barra invertida)
Z'2C' - Z
Z'2D' - X
Z'2E' - C
Z'2F' - V
Z'30' - B
Z'31' - N
Z'32' - M
Z'33' - , (vírgula)
Z'34' - . (ponto)
Z'35' - ; (ponto e vírgula)
Z'36' - Shift direito
Z'37' - * (no teclado numérico)
Z'38' - Alt esquerdo
Z'39' - Espaço
Z'3A' - Caps Lock
Z'3B' - F1
Z'3C' - F2
Z'3D' - F3
Z'3E' - F4
Z'3F' - F5
Z'40' - F6
Z'41' - F7
Z'42' - F8
Z'43' - F9
Z'44' - F10
Z'45' - Num Lock
Z'46' - Scroll Lock
Z'47' - 7 (teclado numérico)
Z'48' - 8
Z'49' - 9
Z'4A' - -
Z'4B' - 4
Z'4C' - 5
Z'4D' - 6
Z'4E' - +
Z'4F' - 1
Z'50' - 2
Z'51' - 3
Z'52' - 0
Z'53' - . (ponto do teclado numérico)
Z'57' - F11
Z'58' - F12
------------------------------------
-> Celular :
I2C_START_TRANSMISSION: Gerar a condição START (SDA LOW, SCL HIGH). Iniciar a comunicação com o TCIC.
I2C_SEND_SLAVE_ADDR_WRITE Z'00': Enviar o endereço do TCIC + bit de escrita (0). Dizer ao TCIC para escutar o endereço de registro.
I2C_SEND_SLAVE_ADDR_READ Z'00': Gerar REPEATED START ou START + Endereço do TCIC + bit de leitura (1). Dizer ao TCIC para enviar os dados.
I2C_WRITE_BYTE (REG_ADDR): Enviar o endereço do registrador interno do TCIC (ex: Z'814E'). Especificar qual dado (status, X, Y, pressão) o TCIC deve retornar.
I2C_READ_BYTE (ACK/NACK): Ler 8 bits do TCIC. Receber o Status, a Posição, ou o valor de Pressão.
I2C_STOP_TRANSMISSION: Gerar a condição STOP (SDA HIGH, SCL HIGH). Finalizar a transação.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-] Consoles:
1. PlayStation:
Cima: Z'00'
Direita: Z'02'
Baixo: Z'04'
Esquerda: Z'06'
Centro: Z'08' ou Z'0F'
Quadrado: Z'60'
X: Z'61'
Bolinha: Z'62'
Triângulo: Z'63'
L1: Z'64'
R1: Z'65'
L2: Z'66'
R2: Z'67'
Share: Z'68'
Options: Z'69'
L3: Z'6C'
R3: Z'6D'
Touchpad: Z'6A'
LEFT_STICK_X (Z'0000' a Z'FFFF'):
LEFT_STICK_Y (Z'0000' a Z'FFFF'):
RIGHT_STICK_X (Z'0000' a Z'FFFF'):
RIGHT_STICK_Y (Z'0000' a Z'FFFF'):
----------------------------------------------
2. Xbox:
D-Pad Cima: 0x01
D-Pad Baixo: 0x02
D-Pad Direita: 0x03
D-Pad Esquerda: 0x04
Start: 0x05
Back: 0x06
L-Stick: 0x07
R-Stick: 0x08
A: 0x0C
B: 0x0D
X: 0x0E
Y: 0x0F
LB: 0x09
RB: 0x0A
LT (0x00 a 0xFF): .byte 0x00
RT (0x00 a 0xFF): .byte 0x00

==========================
-} Mapeamento de Memória:
==========================
> Usa uma interrupção para ver o mapa de memória, permitindo que você possa escrever na RAM.

1. x16:
CALL INT Z'15h', %ACUMULADOR=E820h
--------------------------
2. x32:
CALL INT Z'00000015', %ACUMULADOR=Z'0000E820'
-------------------------------------
3. x64:
CALL INT Z'0000000000000015', %ACUMULADOR=Z'000000000000E820'

=========
-} Disco:
=========
Leitura: Mover %ACUMULADOR para 0x38(%BASE) em um loop, realizar operação lógica AND com %ACUMULADOR e valor 0x88, comparar %ACUMULADOR com 0 e pular para o loop se %ACUMULADOR não for zero.
Escrita: Mover o valor 0x1 para %ACUMULADOR

============
-} Gráficos:
============
! Nota: Todos os dados devem estar em *MAIN_ADDR
> Requer a chamada de códigos do GUC/SMU/GSP/SOC-GSP, e o código inteiro em um .sys/.ko empacotado com um executor dele.

1. Comandos do GSP (CALL para uso):
- Padrão de Alocação é o tamanho da memória em bytes, HeapID é "VRAM" e 4096 é o alinhamento em PCs/Consoles.

-> Parâmetros:
INTEGER SIZE, ALIGN
PARAMETER (SIZE = 1000000, ALIGN = 4096)
CHARACTER HEAPID
PARAMETER (HEAPID = "VRAM")

-] Intel:
Iniciar: GUC_CMD_GLOBAL_INIT (Antes do Alloc)
Alocar: GUC_CMD_ALLOC_RESOURCE <SIZE>, <HeapID>, <ALIGN>
Escrever: GUC_CMD_QUEUE_RING_FLUSH (Após a escrita na memória de vídeo.)
--------------------------------------------------------
-] AMD:
Iniciar: SMU_CMD_INIT_PM
Alocar/Escrever: SMU_CMD_ALLOCATE_MEM <SIZE>, <HeapID>, <ALIGN>
---------------------------------------------------------------
-] NVidia:
Iniciar: GSP_CMD_INIT_RM $0x1
Alocar: GSP_CMD_ALLOC_OBJECT <SIZE>, <HeapID>, <ALIGN>
Escrever: GSP_CMD_SUBMIT_WORK
------------------------------------------------------
-] SOC-GSP:
Iniciar: GSP_RESET Z'1', GSP_CLK_CFG Z'0'
Ler (Requer comparação com zero e loop caso não seja zero): JOB_STATUS
Escrever: JOB_RING_BASE $0x0, JOB_RING_WTPR Z'0'
----------------------------------------------------------------------------------------------------------
2. Elementos Gráficos:
█ Bloco Sólido: Z'DB'
▓ Sombra Escura: Z'B2'
▒ Sombra Média: Z'B1'
░ Sombra Leve: Z'B0'
----------------------
3. Células, Valores RGB Indexados e Coordenadas de Posição:
> Um valor de cor varia de 0 a 255 (Z'00' a Z'FF'), o OFFSET deve estar em *BASE_ADDR, e os dados gráficos da célula em *MAIN_ADDR.
> Fórmula do OFFSET: Offset da Célula = (Y_Célula * 160 + X_Célula * 3)

.section .data
R = Z'00' a Z'FF': Nível da Cor Vermelha
G = Z'00' a Z'FF': Nível da Cor Verde
B = Z'00' a Z'FF': Nível da Cor Azul
INTEGER RESOLUTION = 160
CHARACTER CELL1 = "desenho"
INTEGER CELL1_OFFSET, CELL1_Y, CELL1_X
PARAMETER WIDTH = 160, DEPTH = 3
CELL1_OFFSET = (CELL1_Y * 160 + CELL1_X * 3)

========================================================
-} Áudio (Para efeitos sonoros e músicas no seu código):
========================================================
! Nota: DELTA.PI deve estar em %CONTADOR e Dados de Áudio em %DADOS.
> Requer "INT 15h/0x15/0x00000015/0x0000000000000015, %ACUMULADOR=E820h/0x0000E820/0x000000000000E820", Delta Pi no Base e chamada de códigos do HDA, além do código de todo o projeto em um arquivo .sys/.ko e seu executor.

1. Chamadas de Comandos do HDA (Universal em PCs):
- Padrôes de formato de stream são NID Z'06', Stream Format Z'200', e Payload Z'441'.
- Padrões de Ativação do Dispositivo de Áudio são 0x40 para a Saída e 0x80 para o Headphone.
CALL SET_STREAM_FORMAT <NID> <STREAM_FORMAT> <PAYLOAD>: Define a taxa, bits e canais para 48kHz/16bit/Estéreo no DAC/ADC.
CALL SET_PIN_WIDGET_CONTROL <NID> <ENABLE_OUT>: Ativa o pino de saída físico (Ex: Headphone) e sua função de saída.
MOV [DELTA_PI], %BASE
CALL SET_DMA_RUN_BIT: Aciona o controlador HDA para iniciar o loop de transferência de dados do Ring Buffer para o CODEC.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Definição de Parâmetros de Áudio, Low/Neg_Max e High/Max:
PI .double 3.14159265358979323846: Número PI.
SAMPLE_RATE = 44100: Frequência de amostragem (Fs).
FREQUENCY = 440: Frequência do seno (f).
DURATION = 1: Duração em segundos.
BITS_PER_SAMPLE = 16: Profundidade de bits.
MAX_AMPLITUDE = 32767: Amplitude de Bits.
NEG_MAX_AMPLITUDE = -32767: Amplitude Negativa de Bits.
------------------------------------------------------------
3. Cálculo da Onda Senoidal:

DOUBLE PRECISION PHASE_ACC = 1
DELTA_PI: .long 42852281: Incremento de Fase (Frequência * 2^32 / Sample Rate).

==============================
-} Online (Intel FW e TCP/IP):
=============================
1. Comandos do Firmware de Rede Intel:
CTRL Z'0000': Controle Geral do Chip (Reset, Enable/Disable)
STATUS Z'0008': Status Geral do Link (Link Up/Down)
EERD Z'0014': Leitura da EEPROM/NVM (para ler o MAC)
IMC Z'00D0': Máscara de Interrupção (para ignorar/habilitar interrupções)
RCTL Z'0100': Controle de Recepção
RAL/RAH Z'5400'/Z'5404': Endereço MAC (Lower/Upper 32 bits)
RDBAL/RDBAH Z'2800'/Z'2804': Endereço Base do Anel de Descritores Rx (Lower/Upper)
RDLEN Z'2808': Tamanho do Anel de Descritores Rx
RDH/RDT Z'2810'/Z'2818': Cabeça (Head) e Cauda (Tail) do Anel Rx
TCTL Z'0400': Controle de Transmissão
TDBAL/TDBAH Z'3800'/Z'3804': Endereço Base do Anel de Descritores Tx
TDLEN Z'3808': Tamanho do Anel de Descritores Tx
TDH/TDT Z'3810'/Z'3818': Cabeça (Head) e Cauda (Tail) do Anel Tx
---------------------------------------------------------------------------------
2. Parâmetros do TCP/IP:

2.1. Frame Ethernet
MAC_DESTINY Z'00': Endereço MAC do próximo dispositivo na rede (roteador ou host final). (Variável)
MAC_ORIGIN Z'06': Seu endereço MAC. (Variável). (Este é o MAC lido do NIC da Intel).
ETHERTYPE Z'0C': Identifica o protocolo da Camada 3. (Padrão/Fixo):Z'0800' para IPv4, Z'0806' para ARP.
PAYLOAD Z'0E': O Cabeçalho IP começa aqui.
CRC (Checksum de Frame): Este campo é gerado e anexado AUTOMATICAMENTE pelo controlador Intel no momento da transmissão.
------------------------------------------------------------------------------------------------------------------------
2.2. Cabeçalho IPv4:
VERSION_IHL Z'00': Geralmente 0x45. (Versão 4, IHL 5 - 20 bytes).
PROTOCOL Z'09': Z'06' (para TCP) ou Z'11' (para UDP).
CHKSUM_HEADER Z'0A': O campo que você deve calcular em bare-metal, usando o algoritmo de Soma Complementar de Um.
IP_ORIGIN Z'0C': Seu Endereço IP. (Variável).
IP_DESTINY Z'10': Endereço IP do host de destino. (Variável).
----------------------------------------------------------------------------------------------------------------
2.3. Cabecalho TCP:
PORT_ORIGIN Z'00': Sua porta (aplicação/serviço local).
PORT_DESTINY Z'02': Porta do serviço remoto (ex: 80, 443).
SEQUENCE Z'04': Posição do primeiro byte de dados do segmento.
ACK (Reconhecimento) Z'08': Próximo número de sequência esperado do lado remoto.
RES_FLAGS Z'0C': Contém o Data Offset e os Control Flags.
WINDOW_SIZE Z'0E': Controle de fluxo (Buffer de recepção disponível).
CHKSUM Z'10': Resultado do cálculo do Pseudo-Cabeçalho + TCP + Dados.
URGENCY_POINT Z'12': Ponto de Urgência Fixo (Geralmente 0x0000).
OPT_FILL Z'14': Usado se o Data Offset for maior que 5.
SYN (Início): Z'02'
SYN-ACK (Resposta): Z'12' (Z'10' ACK + Z'02' SYN)
SIM-ACK (Reconhecimento): Z'10'
PSH-ACK (Enviar Dados): Z'18' (Z'08' PSH + Z'10' ACK)
FIN-ACK (Encerrar): Z'11' (Z'01' FIN + Z'10' ACK)
RST (Resetar): Z'04'

3. APIC:
Configuração da APIC: Sequências de OUTs e MOVs para os endereços do Firmware de Rede Intel.
Rotina de Serviço: Salvar Contexto, Ler e Escrever nos pacotes do NIC, e restaurar.
Loops: Loop de Jumps entre as tarefas.
____________________________________________________________________________________________
