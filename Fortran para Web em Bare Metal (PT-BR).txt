=============================================================================================================================
-} Fortran77 para Bare Metal Web (Regras, Operadores e Palavras-Chave, Mapeamento de Memória, Web, Entrada, Gráficos, Áudio):
=============================================================================================================================
========================================
-} Regras do Formato Fixo do Fortran 77:
========================================
1. Coluna 1, Regra: Se a coluna 1 contiver um C, um * (asterisco), ou um D (dependendo do compilador), a linha inteira é tratada como um comentário e ignorada.

2. Colunas 1 a 5, Regra: Espaço reservado para números inteiros (rótulos) de 1 a 5 dígitos. Esses rótulos são usados por instruções como GO TO, DO, READ e WRITE (para referenciar instruções FORMAT). O número não precisa estar justificado à direita.

3. Coluna 6, Regra: Se uma instrução for muito longa para caber na coluna 72, a próxima linha é uma continuação se a coluna 6 contiver qualquer caractere que não seja um espaço ou 0 (zero). O + ou um número sequencial eram populares.

4. Colunas 7 a 72, Regra: Aqui é onde o código real reside (declarações, instruções executáveis). Importante: Os espaços em branco são geralmente ignorados pelo Fortran 77 (com exceção de strings de caracteres). Por exemplo, I N T E G E R é lido como INTEGER.

5. Colunas 73 a 80, Regra: Essas colunas são ignoradas pelo compilador. Elas eram usadas para armazenar números de sequência em cartões perfurados para ajudar na classificação, caso os cartões fossem misturados.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

===============================
-} Operadores e Palavras-Chave:
===============================
.AND.: E Lógico. "(X .GT. 5) .AND. (Y .LT. 10)"
.OR.: OU Lógico. "(A .EQ. B) .OR. (C .NE. D)"
.NOT.: NÃO Lógico. ".NOT. (FLAG .EQ. .TRUE.)"
.EQ.: Igual a. "IF (A .EQ. B) THEN"
.NE.: Diferente de. "IF (X .NE. 0) THEN"
.LT.: Menor que. "IF (I .LT. MAX) THEN"
.LE.: Menor ou igual a. "IF (T .LE. 100.0) THEN)"
.GT.: Maior que. "IF (J .GT. 50) THEN"
.GE.: Maior ou igual a "IF (K .GE. MIN_VAL) THEN"
PROGRAM: Inicia o programa principal.
ENDPROGRAM: Finaliza o programa principal.
INTEGER: Declara uma variável como número inteiro.
REAL: Declara uma variável como número de ponto flutuante (precisão simples).
DOUBLE PRECISION: Declara uma variável de ponto flutuante de precisão dupla.
COMMON: Aloca uma área de memória de acesso global. Qualquer rotina que inclua a mesma instrução COMMON (com os mesmos nomes de variáveis ou uma lista de variáveis de tamanho compatível) pode acessar e modificar esses dados.
COMPLEX: Declara uma variável como número complexo.
LOGICAL: Declara uma variável booleana (.TRUE. ou .FALSE.).
CHARACTER: Declara uma variável de string.
DIMENSION: Declara o rank e os limites de um array.
PARAMETER: Declara uma constante simbólica.
FUNCTION: Inicia a definição de uma função (retorna um valor).
SUBROUTINE: Inicia a definição de uma sub-rotina (não retorna valor por nome).
CALL: Invoca/executa uma sub-rotina.
CONTAINS: Separa o código principal de procedimentos internos (FUNCTION ou SUBROUTINE).
RETURN: Sai de uma função ou sub-rotina.
IF: Inicia uma estrutura condicional.
THEN: Usado após a condição IF.
ELSE: Bloco de código executado se a condição IF for falsa.
ELSE IF Bloco de código para uma condição alternativa.
ENDIF: Finaliza a estrutura condicional IF.
DO: Inicia um loop (iteração).
ENDDO: Finaliza o loop DO.
CYCLE: Pula para a próxima iteração do loop DO.
EXIT: Sai imediatamente de um loop DO.
READ: Comando de entrada de dados (e.g., do teclado ou arquivo).
WRITE: Comando de saída de dados (e.g., para tela ou arquivo).
OPEN: Abre um arquivo para I/O.
CLOSE: Fecha um arquivo aberto.
UNIT: Argumento que especifica um número para o canal de I/O.
FORMAT: Especifica o layout da entrada ou saída formatada.
STOP: Encerra a execução do programa de forma normal.
----------------------------------------------------------------------------------------

==========================
-} Mapeamento de Memória:
==========================
-> Usa uma interrupção para ver um mapa de memória, permitindo que escreva nela.

1. Interrupções de Discos Rígidos:
Leitura: CALL Z'13h'/Z'00000013'/Z'0000000000000013', Z'42h'/Z'00000042'/Z'0000000000000042'
Escrita: CALL Z'13h'/Z'00000013'/Z'0000000000000013', Z'43h'/Z'00000043'/Z'0000000000000043'

2. Interrupções de RAM/VRAM:
Mapeamento de RAM: CALL Z'15h'/Z'00000015'/Z'0000000000000015', Z'E820h'/Z'0000E820'/Z'000000000000E820'
Mapeamento de VRAM: CALL Z'10h'/Z'00000010'/Z'0000000000000010'

3. Mapeamento de Disco:
Uso: Definir DAP, Chamar INT de Leitura de Disco Rígido, e depois Chamar INT de Escrita no Disco Rígido.

-> DAP (Disk Address Packet):
Z'00' Tamanho do DAP: Deve ser Z'10' (16 bytes).
Z'01' Reservado: Deve ser Z'00'.
Z'02' Contagem de Blocos: O número de setores (blocos) a serem lidos. (Ex: Z'0001' para ler apenas um setor).
Z'04' Endereço de Transferência (Offset:Segmento): O endereço de 32 bits (16:16) na RAM onde os dados lidos do disco serão enviados. É o endereço de destino (o buffer).
Z'08' Inicial: O endereço do setor no disco a partir do qual a leitura deve começar. (Ex: Z'0000000000000001' para o primeiro setor após o MBR).

INTEGER DAP_SIZE, DAP_RESV, DAP_BLK_CNT, DAP_OFFSET
COMMON DAP_SIZE, DAP_RESV, DAP_BLK_CNT, DAP_OFFSET
DAP_SIZE = Z'10'
DAP_RESV = Z'00'
DAP_BLK_CNT = Z'0001'
DAP_OFFSET = MMAP16_PTR/MMAP32_PTR/MMAP64_PTR

4. Mapeamento de RAM:
INTEGER MMAP16_PTR, MMAP32_PTR, MMAP64_PTR, VMMAP16_PTR, VMMAP32_PTR, VMMAP64_PTR
COMMON MMAP16_PTR, MMAP32_PTR, MMAP64_PTR, VMMAP16_PTR, VMMAP32_PTR, VMMAP64_PTR
MMAP16_PTR = Z'E820h'
MMAP32_PTR = Z'0000E820'
MMAP64_PTR = Z'000000000000E820'
VMMAP16_PTR = Z'10h'
VMMAP32_PTR = Z'00000010'
VMMAP64_PTR = Z'0000000000000010'
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================
-} Web (TCP/IP):
================
-> Requer que o código inteiro esteja em um .sys/.ko, e PAYLOAD atrelado a MMAP16_PTR/MMAP32_PTR/MMAP64_PTR.

1. Comandos Fixos do Firmware de Rede Intel (Variáveis definidas, mas usando CALL para chamar eles.):
CTRL Z'0000': Controle Geral do Chip (Reset, Enable/Disable)
STATUS Z'0008': Status Geral do Link (Link Up/Down)
EERD Z'0014': Leitura da EEPROM/NVM (para ler o MAC)
IMC Z'00D0': Máscara de Interrupção (para ignorar/habilitar interrupções)
RCTL Z'0100': Controle de Recepção
RAL Z'5400': Endereço MAC (Lower 32-bit).
RAH Z'5404': Endereço MAC (Upper 32-bit)
RDBAL Z'2800': Endereço Base do Anel de Descriptores Rx (Lower)
RDBAH Z'2804': Endereço Base do Anel de Descritores Rx (Upper)
RDLEN Z'2808': Tamanho do Anel de Descritores Rx
RDH Z'2810' Cabeça (Head) do Anel RX
RDT Z'2818': Cauda (Tail) do Anel Rx
TCTL Z'0400': Controle de Transmissão
TDBAL Z'3800': Endereço Base Baixo do Anel de Descritores Tx.
TDBAH Z'3804': Endereço Base Alto do Anel de Descritores Tx
TDLEN Z'3808': Tamanho do Anel de Descritores Tx
TDH Z'3810': Cabeça (Head) do Anel Tx
TDT Z'3818': Cauda (Tail) do Anel Tx
---------------------------------------------------------------------------------
2. Parâmetros do TCP/IP (Variáveis Definidas do Pacote):

2.1. Frame Ethernet:
INTEGER MAC_DESTINY = Z'00': Endereço MAC do próximo dispositivo na rede (roteador ou host final).
INTEGER MAC_ORIGIN = Z'06': Seu endereço MAC. Este é o MAC lido do NIC da Intel.
INTEGER ETHERTYPE = Z'0800' (Fixo): Identifica o protocolo da Camada 3. Z'0800' para IPv4, Z'0806' para ARP.
INTEGER PAYLOAD =Z'0E': O Cabeçalho IP começa aqui.
INTEGER CRC =(Checksum de Frame): Este campo é gerado e anexado AUTOMATICAMENTE pelo controlador Intel no momento da transmissão.
------------------------------------------------------------------------------------------------------------------------
2.2. Cabeçalho IPv4:
INTEGER VERSION_IHL = Z'00': Geralmente 0x45. (Versão 4, IHL 5 - 20 bytes).
INTEGER PROTOCOL = Z'06': Z'06' (para TCP) ou Z'11' (para UDP).
INTEGER CHKSUM_HEADER = Z'0A': O campo que você deve calcular em bare-metal, usando o algoritmo de Soma Complementar de Um.
INTEGER IP_ORIGIN = Z'0C': Seu Endereço IP. (Variável).
INTEGER IP_DESTINY= Z'10': Endereço IP do host de destino. (Variável).
----------------------------------------------------------------------------------------------------------------
2.3. Cabecalho TCP:
INTEGER PORT_ORIGIN = Z'00' (Fixo): Sua porta (aplicação/serviço local).
INTEGER PORT_DESTINY = Z'02'(Fixo): Porta do serviço remoto (ex: 80, 443).
INTEGER SEQUENCE = Z'04' (Variável): Posição do primeiro byte de dados do segmento.
INTEGER ACK = Z'08' (Reconhecimento Variável): Próximo número de sequência esperado do lado remoto.
INTEGER RES_FLAGS = Z'0C' (Variável): Contém o Data Offset e os Control Flags.
INTEGER WINDOW_SIZE = Z'0E' (Variável): Controle de fluxo (Buffer de recepção disponível).
INTEGER CHKSUM = Z'10' (Variável): Resultado do cálculo do Pseudo-Cabeçalho + TCP + Dados.
INTEGER URGENCY_POINT = Z'12' (Fixo): Ponto de Urgência Fixo (Geralmente 0x0000).
INTEGER OPT_FILL = Z'14' (Variável): Usado se o Data Offset for maior que 5.
INTEGER SYN = Z'02': Início Fixo.
INTEGER SYN-ACK = Z'12': Resposta Fixa (Z'10' ACK + Z'02' SYN).
INTEGER SIM-ACK = Z'10': Reconhecimento Fixo.
INTEGER PSH-ACK = Z'18': Envio de Dados Fixo (Z'08' PSH + Z'10' ACK).
INTEGER FIN-ACK = Z'11': Encerramento Fixo (Z'01' FIN + Z'10' ACK).
INTEGER RST = Z'04':(Reinício Fixo.):
____________________________________________________________________________________________

========================================================================
-} Entrada (Para suporte de controles do Computador, Celular e Console):
========================================================================
Uso: CALL [Função/Comando] e IF PRESSED_KEY == 1
-------------------------------------------------------------------------
-> Parâmetros-Chave:
PRESSED_KEY = Z'00': Deve ser movido para %ACUMULADOR
---------------------------------------------------------
-> Computador:
Z'01' - Esc
Z'02' - 1
Z'03' - 2
Z'04' - 3
Z'05' - 4
Z'06' - 5
Z'07' - 6
Z'08' - 7
Z'09' - 8
Z'0A' - 9
Z'0B' - 0
Z'0C' - -
Z'0D' - =
Z'0E' - Backspace
Z'0F' - Tab
Z'10' - Q
Z'11' - W
Z'12' - E
Z'13' - R
Z'14' - T
Z'15' - Y
Z'16' - U
Z'17' - I
Z'18' - O
Z'19' - P
Z'1A' - ´ (acento agudo)
Z'1B' - [ (abre colchete)
Z'1C' - Enter
Z'1D' - Ctrl esquerdo
Z'1E' - A
Z'1F' - S
Z'20' - D
Z'21' - F
Z'22' - G
Z'23' - H
Z'24' - J
Z'25' - K
Z'26' - L
Z'27' - Ç
Z'28' - ~ (til)
Z'29' - ` (crase)
Z'2A' - Shift esquerdo
Z'2B' - \ (barra invertida)
Z'2C' - Z
Z'2D' - X
Z'2E' - C
Z'2F' - V
Z'30' - B
Z'31' - N
Z'32' - M
Z'33' - , (vírgula)
Z'34' - . (ponto)
Z'35' - ; (ponto e vírgula)
Z'36' - Shift direito
Z'37' - * (no teclado numérico)
Z'38' - Alt esquerdo
Z'39' - Espaço
Z'3A' - Caps Lock
Z'3B' - F1
Z'3C' - F2
Z'3D' - F3
Z'3E' - F4
Z'3F' - F5
Z'40' - F6
Z'41' - F7
Z'42' - F8
Z'43' - F9
Z'44' - F10
Z'45' - Num Lock
Z'46' - Scroll Lock
Z'47' - 7 (teclado numérico)
Z'48' - 8
Z'49' - 9
Z'4A' - -
Z'4B' - 4
Z'4C' - 5
Z'4D' - 6
Z'4E' - +
Z'4F' - 1
Z'50' - 2
Z'51' - 3
Z'52' - 0
Z'53' - . (ponto do teclado numérico)
Z'57' - F11
Z'58' - F12
------------------------------------
-> Celular :
I2C_START_TRANSMISSION: Gerar a condição START (SDA LOW, SCL HIGH). Iniciar a comunicação com o TCIC.
I2C_SEND_SLAVE_ADDR_WRITE Z'00': Enviar o endereço do TCIC + bit de escrita (0). Dizer ao TCIC para escutar o endereço de registro.
I2C_SEND_SLAVE_ADDR_READ Z'00': Gerar REPEATED START ou START + Endereço do TCIC + bit de leitura (1). Dizer ao TCIC para enviar os dados.
I2C_WRITE_BYTE (REG_ADDR): Enviar o endereço do registrador interno do TCIC (ex: Z'814E'). Especificar qual dado (status, X, Y, pressão) o TCIC deve retornar.
I2C_READ_BYTE (ACK/NACK): Ler 8 bits do TCIC. Receber o Status, a Posição, ou o valor de Pressão.
I2C_STOP_TRANSMISSION: Gerar a condição STOP (SDA HIGH, SCL HIGH). Finalizar a transação.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-] Consoles:
1. PlayStation:
Cima: Z'00'
Direita: Z'02'
Baixo: Z'04'
Esquerda: Z'06'
Centro: Z'08' ou Z'0F'
Quadrado: Z'60'
X: Z'61'
Bolinha: Z'62'
Triângulo: Z'63'
L1: Z'64'
R1: Z'65'
L2: Z'66'
R2: Z'67'
Share: Z'68'
Options: Z'69'
L3: Z'6C'
R3: Z'6D'
Touchpad: Z'6A'
LEFT_STICK_X (Z'0000' a Z'FFFF'):
LEFT_STICK_Y (Z'0000' a Z'FFFF'):
RIGHT_STICK_X (Z'0000' a Z'FFFF'):
RIGHT_STICK_Y (Z'0000' a Z'FFFF'):
----------------------------------
2. Xbox:
D-Pad Cima: Z'01'
D-Pad Baixo: Z'02'
D-Pad Direita: Z'03'
D-Pad Esquerda: Z'04'
Start: Z'05'
Back: Z'06'
L-Stick: Z'07'
R-Stick: Z'08'
A: Z'0C'
B: Z'0D'
X: Z'0E'
Y: Z'0F'
LB: Z'09'
RB: Z'0A'
LT (Z'00' a Z'FF'):
RT (Z'00' a Z'FF'):
-------------------

============
-} Gráficos:
============
-> Requer todos os Dados Gráficos no PAYLOAD e um valor de cor varia de 0 a 255 (Z'00' a Z'FF').
-> Fórmula do OFFSET: Offset da Célula = ((CELL1_Y * WIDTH * DEPTH) + (CELL1_X * DEPTH)

1. Elementos Gráficos, Células, Valores RGB Indexados e Coordenadas de Posição:
█ Bloco Sólido: Z'DB'
▓ Sombra Escura: INTEGER HI_SHADE = Z'B2'
▒ Sombra Média: INTEGER MID_SHADE = Z'B1'
░ Sombra Leve: INTEGER LOW_SHADE = Z'B0'

INTEGER R (Z'00' a Z'FF'): Nível da Cor Vermelha
INTEGER G (Z'00' a Z'FF'): Nível da Cor Verde
INTEGER B (Z'00' a Z'FF'): Nível da Cor Azul
INTEGER CELL1_X, CELL1_Y
PARAMETER WIDTH, DEPTH
CHARACTER CELL1
INTEGER CELL1_OFFSET

WIDTH = 160
DEPTH = 3
R = Z'FF'
G = Z'00'
B = Z'FF
CELL1 = "desenho"
CELL_X = 80
CELL_Y = 25
INTEGER CELL1_OFFSET = (CELL1_Y * WIDTH * DEPTH) + (CELL1_X * DEPTH)
---------------------------------------------------------------------------------------

========================================================
-} Áudio (Para efeitos sonoros e músicas no seu código):
========================================================
-> Requer Delta Pi no PAYLOAD.

1. Definição de Parâmetros de Áudio, Low/NegMax, High/Max e Geração de Onda Senoidal:
DOUBLE PRECISION PI = 3.14159265358979323846: Número PI.
INTEGER SAMPLE_RATE = 44100: Frequência de amostragem (Fs).
INTEGER FREQUENCY = 440: Frequência do seno (f).
INTEGER DURATION = 1: Duração em segundos.
INTEGER BITS_PER_SAMPLE = 16: Profundidade de bits.
INTEGER MAX_AMPLITUDE = 32767: Amplitude de Bits.
INTEGER NEG_MAX_AMPLITUDE = -32767: Amplitude Negativa de Bits.
DOUBLE PRECISION PHASE_ACC = 1
DELTA_PI: (FREQUENCY * 2.0 * PI / SAMPLE_RATE).
